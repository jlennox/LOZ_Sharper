using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

#pragma warning disable RS1035

namespace z1.SourceGenerator;

[Generator]
public sealed class ActorSerializerGenerator : IIncrementalGenerator
{
    public const string SourceGenerationSpecTrackingName = "SourceGenerationSpec";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        static bool IsActor(INamedTypeSymbol? symbol)
        {
            if (symbol is null) return false;
            for (var baseType = symbol; baseType is not null; baseType = baseType.BaseType)
            {
                if (baseType.ToDisplayString() == "z1.Actors.Actor")
                {
                    return true;
                }
            }
            return false;
        }

        var markedClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                transform: static (ctx, _) =>
                {
                    var classSyntax = (ClassDeclarationSyntax)ctx.Node;
                    var symbol = ctx.SemanticModel.GetDeclaredSymbol(classSyntax) as INamedTypeSymbol;
                    return symbol;
                })
            .Where(IsActor)
            .WithTrackingName(SourceGenerationSpecTrackingName);

        context.RegisterSourceOutput(markedClasses, (spc, classSymbol) =>
        {
            if (classSymbol is null) return;

            var ns = classSymbol.ContainingNamespace.ToDisplayString();
            var className = classSymbol.Name;

            if (classSymbol.IsGenericType)
            {
                className = $"{classSymbol.Name}<{string.Join(", ", classSymbol.TypeArguments.Select(t => t.ToDisplayString()))}>";
            }

            static bool ShouldSerializeMember(ISymbol symbol)
            {
                return symbol switch
                {
                    IFieldSymbol fieldSymbol => fieldSymbol is
                    {
                        IsStatic: false,
                        IsImplicitlyDeclared: false,
                    },
                    IPropertySymbol propertySymbol => propertySymbol is
                    {
                        IsStatic: false,
                        IsImplicitlyDeclared: false,
                        IsReadOnly: false,
                        IsWriteOnly: false,
                    },
                    _ => false
                };
            }

            File.AppendAllText(@"C:\users\joe\desktop\delete\test.txt",
                $$"""
                  + {{className}}
                  """);

            var properties = classSymbol.GetMembers().Where(ShouldSerializeMember).ToArray();

            var baseCompare = "";
            var genericBaseTypeList = classSymbol.BaseType?.TypeArguments.Select(t => t.ToDisplayString()).ToArray() ?? [];
            if (classSymbol.BaseType is not null && IsActor(classSymbol.BaseType))
            {
                if (classSymbol.BaseType.TypeArguments.Length == 0)
                {
                    baseCompare = $"if (!{classSymbol.BaseType.Name}.Compare(a, b)) return false;";
                }
                else
                {
                    File.AppendAllText(@"C:\users\joe\desktop\delete\test.txt",
                        $$"""
                        {{classSymbol.Name}} -> {{classSymbol.BaseType.Name}}
                        <{{string.Join(", ", classSymbol.BaseType.TypeParameters.Select(t => t.ToDisplayString()))}}>
                        <2  {{string.Join(", ", genericBaseTypeList)}}>

                        """);
                    baseCompare = $"if (!{classSymbol.BaseType.Name}<{string.Join(", ", classSymbol.BaseType.TypeArguments.Select(t => t.ToDisplayString()))}>.Compare(a, b)) return false;";
                }
            }

            var sb = new StringBuilder(
                $$"""
                // <auto-generated />
                using System;
                using System.Runtime.CompilerServices;
                using System.Runtime.InteropServices;

                namespace {{ns}};

                internal partial class {{className}}
                {
                    public static bool Compare({{className}} a, {{className}} b)
                    {
                        {{baseCompare}}
                        return {{string.Join(" && ", properties.Select(static t => $"a.{t.Name} == b.{t.Name}\n"))}};
                    }

                    public static unsafe void Write({{className}} instance, Stream stream)
                    {
                        Span<byte> buffer = stackalloc byte[16];
                """);

            foreach (var property in properties)
            {
                if (property is IFieldSymbol field)
                {
                    if (field.Type is INamedTypeSymbol { IsValueType: true, IsReadOnly: false })
                    {
                        sb.Append(
                            $$"""

                                    MemoryMarshal.Write<{{field.Type.ToDisplayString()}}>(buffer, ref instance.{{field.Name}});
                                    stream.Write(buffer[..sizeof({{field.Type.ToDisplayString()}})]);
                            """);
                    }
                }
            }

            sb.Append(
                $$"""
                      }

                      public static unsafe void Read({{className}} instance, Stream stream)
                      {
                          Span<byte> buffer = stackalloc byte[16];
                  """);

            foreach (var property in properties)
            {
                if (property is IFieldSymbol field)
                {
                    if (field.Type is INamedTypeSymbol { IsValueType: true, IsReadOnly: false })
                    {
                        sb.Append(
                            $$"""

                                    stream.Read(buffer[..sizeof({{field.Type.ToDisplayString()}})]);
                                    instance.{{field.Name}} = Unsafe.ReadUnaligned<{{field.Type.ToDisplayString()}}>(ref MemoryMarshal.GetReference(buffer));
                            """);
                    }
                }
            }

            sb.Append("\n}");
            sb.Append("\n}");

            spc.AddSource($"{classSymbol.Name}{string.Join(".", genericBaseTypeList)}Serializer.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        });
    }
}